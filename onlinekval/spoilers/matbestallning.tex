\section*{F - Matbeställning}

Vi vill visa att följande giriga algoritm alltid ger bästa svaret: ``Betrakta alla möjliga maträttsbyten som går att göra, ta det billigaste och utför det och upprepa sedan''.
Vi menar att ett byte bara är möjligt ifall personen som byter just nu har valt en rätt som någon annan också valt, och rätten som personen byter till har just nu ingen valt.
Ifall detta inte är uppfyllt är ju bytet helt onödigt. Som vanlig med giriga algoritmer är det ganska intuitivt varför det fungerar, men vi ska här försöka visa det mer rigoröst.

Algoritmen kan bara gå fel ifall vi genom att ta den billigaste på något sätt förstör för en alternativ konfiguration som hade varit billigare. Det enda ``negativa'' med att göra detta byte är att personen vi byter och rätten vi byter till inte kan användas igen, så vi behöver bara betrakta de potentiella alternativa bytena som använder dessa, och se att kostnaden inte blir bättre. Säg att vi har fyra rätter $a, b, c$ och $d$ så att $c_a \le c_b \le c_c \le c_d$, och säg att det billigaste valet just nu är att låta en person byta från en rätt $b$ till rätt $c$. Att någon annan ska byta till rätt c, säg från en rätt a, och att personen som köpte b ska byta till någon annan rätt, säg d, kostar exakt $(c_c-c_a)+(c_d-c_b) = (c_d-c_a)+(c_c-c_b)$. Det är exakt lika mycket som det kostar att utföra bytet $b \rightarrow c$ och sedan $d \rightarrow a$. Vi behöver inte betrakta fallet där någon av $c_a$ eller $c_d$ ligger mellan $c_b$ och $c_c$, eftersom då är inte $c_b \rightarrow c_c$ det billigaste  Alltså kan det aldrig vara suboptimalt att göra detta billigaste byte $b \rightarrow c$.

Nu har vi direkt en lösning som kör i $O(km^2 + n)$ tid, eller möjligtvis $O(km + n)$, som går ut på att $k$ gånger leta upp det minsta bytet som går att utföra, utföra det och upprepa. För att få en $O(m \log m + n)$-lösning behövs lite fler insikter.

Vi tänker att vi vill skapa en lista över alla byten som görs när man följer algoritmen ovan, och sedan välja ut de $k$ billigaste bland dessa. Den första insikten som behövs är att vi kan sortera alla rätter och gå igenom dem från dyrast till billigast, och ifall vi kommer till en dubbelbokad rätt parar vi ihop de överflödiga personerna där med den billigaste dyrare rätten. För att bevisa att detta alltid ger de byten vi vill ha använder vi igen argumentet om när det kan gå fel. Här kan det bara gå fel ifall vi genom att para ihop en person $i$ med en rätt $j$ den ska byta till förhindrar ett billigare byte från att ske. Men $i$ kan ju inte ha ett billigare byte, eftersom den paras ihop med närmaste rätten, och $j$ kan inte ha ett billigare byte, eftersom alla dubbelbokade rätter mellan $i$ och $j$ redan har parats ihop med en ledig rätt som ligger närmre sig själv i pris än $i$ (annars skulle ju inte $i$ vara ledig). 

Den andra insikten som behövs är att vi kan implementera detta snabbt och smidigt genom att ha en stack som hela tiden innehåller alla "lediga" rätter (de som ingen valt från början och som vi inte än parat ihop), sorterad så att billigare rätter ligger högre upp i stacken. Så fort vi kommer till en ny ledig rätt bara lägger vi på den på stacken, och när vi kommer till en dubbelbokad rätt så tar vi och parar ihop alla personer som valt den rätten (förutom en) med de översta rätterna i stacken. Då de översta i stacken var de som lades till senast så kommer de vara exakt de billigaste rätterna som man kan byta till som inte redan någon bytt till.

Eftersom varje rätt bara läggs på i stacken och plockas bort från stacken maximalt en gång går lösningen linjärt i antalet rätter, bortsett steget att sortera alla rätter, vilket är $O(m \log m)$. Även genomgången av personerna går i linjär tid. Tidskomplexiteten är alltså $O(m \log m + n)$. Här är en exempellösning i python:

\lstinputlisting{matbestallning.py}
